Ejecutable como documento HTML5
    con autor allnulled
    con nombre index
    con versi√≥n 1
<head>
    <title>üåê SQLite UI üåê</title>
    <meta charset="utf8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="lib/win7/win7.scoped.2.css" />
    <link rel="stylesheet" type="text/css" href="lib/theme/theme.css" />
    <script src="lib/calo/calo.js"></script>
    <script src="lib/sql-en-castellano/sql-en-castellano.parser.js"></script>
    <script src="lib/sqlite3/sqlite3.js"></script>
</head>
<body><div id="app"></div></body>.

asigno window.PaginaDeInicio como un componente vue2 con nombre "PaginaDeInicio" con plantilla {
  <div class="PaginaDeInicio Component">
    <h5>üåê SQLite UI üåê</h5>
    <div>
      <button style="width:100%;" v-on:click="ejecutar_sql">‚ñ∂ Execute</button>
    </div>
    <div>
      <textarea class="console_style" v-model="script_de_entrada"></textarea>
    </div>
    <div>
      <textarea class="console_style output_style" v-model="script_de_salida"></textarea>
    </div>
  </div>
} con l√≥gica {
  retorno {
    propiedad props como {
      propiedad root como {
        propiedad type como Object.
        propiedad required como true.
      }.
    }.
    m√©todo data donde {
      retorno {
        script_de_entrada: "",
        script_de_salida: ""
      }.
    }.
    propiedad methods como {
      m√©todo as√≠ncrono ejecutar_sql donde {
        creo sql como this.script_de_entrada.
        creo inicio como un nuevo Date().
        creo resultado como as√≠ncronamente this.root.$db.run(sql).
        creo finalizamiento como un nuevo Date().
        creo tardanza como finalizamiento - inicio.
        asigno this.script_de_salida como resultado textualizado + "\n\nRespuesta procesada en " + (tardanza / 1000) + " segundos.".
      } en errores hago this.root.gestion_de_error(error).
    }.
    propiedad watch como {}.
    propiedad computed como {}.
    m√©todo beforeCreate donde {}.
    m√©todo created donde {}.
    m√©todo beforeMount donde {}.
    m√©todo mounted donde {}.
    m√©todo beforeUpdate donde {}.
    m√©todo updated donde {}.
    m√©todo beforeUnmount donde {}.
    m√©todo unmounted donde {}.
    m√©todo activated donde {}.
    m√©todo deactivated donde {}.
  }.
}.

asigno window.App como una aplicaci√≥n vue2 con nombre "App" con rutas [{
  propiedad path como "/".
  propiedad name como "PaginaDeInicio".
  propiedad component como PaginaDeInicio.
  propiedad props como {}.
}] con traducciones {
    propiedad es como {}.
    propiedad en como {}.
    propiedad ca como {}.
} con plantilla {
  <div class="App Component Castelog-app win7">
    <router-view :root="this"></router-view>
    <div class="puerto_de_errores" v-if="errores && errores.length">
      <div class="caja_1">
        <table class="tabla_de_error" v-for="error, error_index in errores" v-bind:key="'error-' + error_index">
          <tr>
            <td style="text-align:center;">
              <div style="text-align:left;">
                <div class="window">
                  <div class="title-bar">
                    <div class="title-bar-text">Error</div>
                  </div>
                  <div class="window-body">
                    <div style="padding:4px;">
                      <div style="max-height:100px;overflow:scroll;">
                        <div><u style="font-weight:bold;">Type:</u> {{ error.name }}</div>
                        <div><u style="font-weight:bold;">Message:</u> {{ error.message }}</div>
                        <div><u style="font-weight:bold;">Stack:</u> {{ error.stack }}</div>
                      </div>
                    </div>
                    <hr />
                    <div style="padding:4px; text-align:right;">
                      <button v-on:click="() => eliminar_error(error_index)">Aceptar</button>
                    </div>
                  </div>
                </div>
              </div>
            </td>
          </tr>
        </table>
      </div>
    </div>
  </div>
} con estilos {
    html {}
    body {}
    .Component {}
    .App {}
} con l√≥gica {
  retorno {
    m√©todo data donde {
      retorno {
        errores: []
      }.
    }.
    propiedad methods como {
      m√©todo gestion_de_error con (error) donde {
        apendizo error en this.errores.
        hago this.$forceUpdate(true).
      }.
      m√©todo eliminar_error con (error_index) donde {
        hago this.errores.splice(error_index, 1).
      }.
      m√©todo obtener_base_de_datos_de_comandos_persistida donde {
        si window.localStorage.__sqlite_ui__ no es tipo texto {
          asigno window.localStorage.__sqlite_ui__ como "[]".
        }.
        intento donde hago window.localStorage.__sqlite_ui__ parseado como JSON en errores asigno window.localStorage.__sqlite_ui__ como "[]".
        retorno window.localStorage.__sqlite_ui__ parseado como JSON.
      }.
      m√©todo guardar_base_de_datos_de_comandos_persistida con (datos) donde {
        asigno window.localStorage.__sqlite_ui__ como datos textualizado.
      }.
      m√©todo as√≠ncrono actualizar_comandos con () donde {
        creo comandos como this.obtener_base_de_datos_de_comandos_persistida().
        desde 0 hasta comandos.length {
          creo comando como comandos[index].
          intento {
            hago as√≠ncronamente this.$db.run(comando, false).
          } en errores {
            imprimo error.
          }.
        }.
      }.
      m√©todo as√≠ncrono generar_base_de_datos con () donde {
        creo sqlite3 como as√≠ncronamente window.sqlite3InitModule().
        creo db como una nueva sqlite3.oo1.DB("/sqlite_ui.sqlite3",'ct').
        retorno {
          native: db,
          run: una lambda con (sql, habilitar_historial o en su defecto true) donde {
            retorno una nueva Promise(una lambda con (ok, fail) donde {
              creo resultRows como [].
              creo resultado como db.exec({
                sql,
                rowMode: "object",
                returnValue: "resultRows"
              }).
              si habilitar_historial y no (sql.trim().toUpperCase().startsWith("SELECT")) {
                imprimo resultado.
                creo comandos como this.obtener_base_de_datos_de_comandos_persistida().
                apendizo sql en comandos.
                hago this.guardar_base_de_datos_de_comandos_persistida(comandos).
              }.
              retorno ok(resultado).
            } en errores retorno fail(error)).
          }
        }.
      }.
    }.
    propiedad watch como {}.
    m√©todo as√≠ncrono beforeMount donde {
      asigno this.$window como window.
      asigno this.$db como as√≠ncronamente this.generar_base_de_datos().
      hago as√≠ncronamente this.actualizar_comandos().
    } en errores imprimo error.
    m√©todo mounted donde {}.
  }.
} montada en "#app".